#ifndef PAGING_H
#define PAGING_H

#include "port.h"
#include "isr.h"
#include "kheap.h"

/* описывает страницу в памяти */
typedef struct page {
	/* страница присутствует в памяти */
	u32_int present    : 1;
	/**
		если сброшен, то страница только для чтения, 
		если установлен, то страница для чтения и записи
	 **/
	u32_int rw         : 1;
	/* если сброшен, то уровень супервизора */
	u32_int user       : 1;
	/** 	
		Было ли обращение к странице после 
		последнего ее обновления?
	 **/
	u32_int accessed   : 1;
	/** 	
		Выполнялась ли запись на страницу 
		после последнего ее обновления? 
	 **/   
	u32_int dirty      : 1;
	/* Все неиспользуемые и зарезервированные биты */
	u32_int unused     : 7;
	/* Адрес фрейма (сдвинут вправо на 12 бит) */
	u32_int frame      : 20;
} page_t;

/* таблица страниц */
typedef struct page_table
{
    page_t pages[1024];
} page_table_t;

typedef struct page_directory
{
    /**
       массив указателей на таблицу страниц
    **/
    page_table_t *tables[1024];
    /**
       директория страниц, в которые входят таблицы страниц,
       указатели указывают физическое местоположение при загрузке в регистр cr3
    **/
    u32_int tables_physical[1024];
    /**
    	Физический адрес tables_physical. Его потребуется использовать в случае,
    	когда мы получаем в ядре память типа куча, а директорий может находиться
    	в любом месте виртуальной памяти.
    **/
    u32_int physical_addr;
} page_directory_t;

/* включение страничной организации памяти */
void paging_init();

/* Загружает указанный директорий страниц в регистр cr3 */
void switch_page_directory(page_directory_t *new);

/**
	Поиск указателя на необходимую страницу.
	Если make == 1 в таблице страниц, в которой эта страница должна располагаться,
	то страница не создана - создайте страницу!
**/
page_t *get_page(u32int address, int make, page_directory_t *dir);

/* handler page_fault */
void page_fault(registers_t regs);

#endif